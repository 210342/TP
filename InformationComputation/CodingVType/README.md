# 1. Coding System versus Type

## 1.1.1. What's the problem? ✍

## 1.1.2. Introduction to Type Concept

In some cases, using the coding system concept that refers directly to alphabet, syntax, and semantics has a few significant drawbacks. First, I should recall that you deal with the binary alphabet in the case of computers because today it is always a binary machine. If it is so obvious we may just simply forget about it. Neglecting the existence of the alphabet causes that we are unable to define syntax rules because there are no signs to be used after the disappearance of the alphabet. Of course, a continuation of this debate in this direction leads us is to a dead end because we cannot neglect the existence of the data and rules we apply to associate meaning to that data. In other words without syntax, the semantics rules cannot be defined. Additionally, users of computers are not willing to deal with the binary alphabet - it is not a natural human environment. The only way to relieve this problem is the assumption that alphabet and syntax exist but are hidden as implementation details.  Anyway, this approach is a foundation to introduce the type concept. Concluding this analysis, further, we should determine the type as an implementation of the coding system.

## 1.1.3. Benefits

Binary data is not our natural environment. I mean part of our natural language, culture, and knowledge we are using on a daily basis. Hence, the possibility to use the type concept instead of a binary coding system could make our life easier because this allows being unaware of unimportant details.  Often we are just not interested in the internal representation of the information. We are not interested in the syntax and the alphabet. We know that the alphabet is binary because we are engaging a computer that is a binary machine. This approach is especially useful in cases when we can use one of the existing well-known types. Hence modern software development environments adopt the type concept somehow and usually provide a vast variety of ready-to-use types. Unfortunately, in a typical case, it doesn't work. Usually, you need computation of custom information that needs dedicated types. Because type is an implementation of a coding system it means that almost always you will need to design custom coding systems indirectly using types. I believe that skills helping accomplish this goal you will find very useful in the professional carrier. My point is that the entry point to accomplish this is a well understanding of the background rules.

## 1.1.4. Drawbacks

Unfortunately, this approach also has drawbacks. Hiding details means that we must apply abstract thinking and be aware when the implicit syntax is an unimportant detail. It is crucial in case you need custom types. New types may be defined from scratch or derived from existing ones inheriting features of the base types.

## 1.1.5. How to deal with the custom definition of the type

Withdrawing the necessity to deal with the binary coding systems to describe information representation in the computer realm is relaxed by some rules that we may apply to define customized types. I will get back to this topic later. To give you just an example I want to mention only the possibility to use constants for selected well-known and usually built-in types. Constants are created using text - a sequence of characters compliant with syntax rules similar to that known in natural languages. To keep the lecture outcome generic, I am not going to spend much time on this because the syntax of constants depends on the development environment. Usually, it is very similar to what we are using on a daily basis. It is worth stressing that the type of a constant is usually tightly coupled with the syntax rules used to create it. I will return shortly to this particular topic.

## 1.1.6. Loosely versus strongly typed approaches

Anyway, it is time to return to programming in practice. Understanding types concept background is vital for your practical achievements provided that we will be able to embed this knowledge in a computer realm using a modern development environment. There are many aspects related to types but only one is critical in the context of the practical approach to programming - it is a reasonable justification of the necessity to use types at all. There is a long-lasting and controversial discussion related to loosely typed and strongly typed approaches to programming. Strongly typed programming wants types specified explicitly. On the contrary, in loosely typed programming we don’t have to explicitly specify types. In this case, the development environment is taking over and the type is inferred by the environment. Coding systems and as a result types must be defined in all cases as a result of the fact that computers always process bitstream but not bitstreams meaning. Therefore impossibility to define explicitly type could be recognized as losing control over the implementation of the information computation process by the programmer.

## 1.1.7. Opening the example

The examples I am going to use you can find in the mpostol/TP GitHub repository. It must be cloned on your computer in advance. Instruction on how to do it you can find in the independent course called `programming in practice executive summary`. I did it already and the code is located in the folder TP. Now I can open the folder with the Visual Studio using the context menu. The screenshot could be different depending on the operating system version you are using. After opening, in the solution tab of the Visual Studio, we have all available solutions. For our discussion, the most appropriate examples are in the "ExDataManagenet" solution.  Double click opens the solution. The code that I will start with is in this unit test project in the file .....To follow me just pause the course and open the example in a separate window. It is a good example of using the unit test to have an executable example to analyze the code features for the education purpose but not testing the program correctness. Again, you can check out the curse `programming in practice executive summary` to get more about this approach.

## 1.1.8. Introduction Variable

In the computer realm, the place where the data - I mean a value - is stored we call a variable. Here in this program, we have a variable declaration. To reestablish the context from the previous lesson assume that our goal is to assign representations of the number four to this variable. In other words, the value is a representation of the number four. In all languages, I know, the variable is always declared as an identifier preceded optionally by a type declaration. For the  CSharp, it is also true. The type declaration - if present -  defines a set of allowed values that can be stored in that variable, that can be represented by that variable, and that can be assigned into that variable. Reversing, if a value is outside of the current set of allowed values, the assignment must be considered as failed, or the variable type must be changed. In general, changing the variable type must lead to the meaning change of stored value. It is the first consequence of applying a loosely typed approach. In this case, the type change occurs as a result of the execution of an operation assigning a new value to the variable. Execution of an operation means that it must happen at run time.  Postponing the type specification up to the run time is called dynamic programming. We will learn more about this approach later during this course. The most important information that you must be aware of is that if something goes wrong with that you will know about it during run-time. It is a possible run-time problem so years could pass after designing this piece of code has been created.

## 1.1.9. Assignment to Float

Similarly in the second line of the example, we have a variable that we are assigning a value representing the number four. As we can see in the first and second lines, the notation is slightly different, the syntax of the constant is different and the type of the second variable is also different. Now let's try to consider for a moment what the word allowed means in the type definition. We say that a type is a set of valid values.

## 1.1.10. Types Compatibilities

Let's un-comment of the next line of code, in which we assign the value representing the number four for the variable defined in the first line. This time the constant has syntax used previously in the second line. At this point, we have an error signaled by the read underscore line, which means that this assignment is not valid and we must investigate why it is incorrect. Well, from the use of the word allowed, it follows that the value on the right-hand side is unacceptable. Well, the value is number four and undoubtedly belongs to the set of allowed values that was declared for the first variable, so the question is how to explain this error. Well, it can be explained in such a way that, in fact, on the right side of the equal sign, we see a constant here, but the compiler sees a construct, which we call an expression. An expression is a sequence of operators and operands, and there are two characteristic features of each expression in all the languages I know. First, each expression evaluates to single value, and second that evaluated value at run-time is always of a well-defined type at design time. In this case, the syntax of this constant will suggest that the expression is of type float. If the value is of type float it could happen that it doesn't belong to the set specified by the long type. Hence, we say that a type is a set of allowed values. In this case, the values ​​may be not allowed and therefore may be outside this set. Let me recall the rule we learned previously - computers always operate on the bitstream but not on the bitstream meaning. Unfortunately, we often forget about this rule and cannot accept situations where we see that number four is not equal to the number four. Sometimes, it is easier to come to terms with that the computer takes over thinking.

## 1.1.11. Operations behavior

The next example in the unit test project called WhyWeNeedTypesIntBehavior is perfect to continue a study on discovering important features of using the type concept to design information representation. In this example, we will focus on the code behavior but not its pattern. Here we have a variable of type int. For this discussion, it is not important to know the allowed set of values that can be assigned to this variable. We can see that number 5 is OK, it meets this requirement and the compiler doesn't complain. It means that the number five is allowed. In the next line, we are assigning to the same variable the previous value that is divided by 2.  Now, on the right side of the equal sign, we have an expression. The type evaluated at designs time is compatible so we don't have any errors. Therefore, the next line checks the final result and compares it to number 2. After running the test we can prove that actually, the result is equal to 2 what is in contrast with the knowledge we learn in the background school. Again investigation is required because it looks like a fundamental inconsistency. In the next few lines, we do the same but now the variable type is float. The result is as expected in the context of our background knowledge. The conclusion is that it could happen only, and only because the division operation behavior depends on the type selection.

## 1.1.12. Type as a Set of Values

Now, it is a perfect time to answer the question of what is the type notion. From the first example related to assigning a value representing a number to the variable, we learn that type should be recognized as a set of allowed values. As the result, we can define the types compatibility concept and protect against the possibility to compute values not belonging to the same set of values at design time. In this context, the type is the definition that is responsible to determine the bitstreams meaning. Again, the computers operate on bitstreams but the type is responsible that the bitstreams meaning is determined by the same relationship, by the same rules. If we hover the cursor over this type identifier, we can see that the full name, the full identifier in this case is `System.Int32`. The identifier must be, as the name suggests, unique, it should be globally unique. For the sake of simplicity, let's skip the discussion on the uniqueness of identifiers. Rather, we are interested in the fact that this identifier will unambiguously indicate the definition. We move the view scope to the type definition by using the alt + F12 key, and we can see that this identifier defines a language construct, which, as we know from the description, is to represent integers. But at the same time, it says in the description that it is about 32-bit integers. So in the name itself, we define the syntax of a bitstream, so we specify that it must be exactly 32 bits long. Concluding, we can say that type is a set of entities, a set of bitstreams that represent certain values. So in this respect, it is similar to the concept of code where we also had a set of words and we had a set of values ​​that the words are represented by. From the next part of the type definition, you will learn while it is so important that any operation is applied to bitstreams that have the meaning assigned according to well-known and provided in advance at design time rules.

## 1.1.13. Type as a set operations

From the example of dividing the number 5 by 2, which is equal to 2 or 2.5 you can learn that depending on the type of operands the operation behavior is different. In other words, we could suppose that type can be recognized also as a set of operations that are performed on the values belonging to a set defined by the type. Considering type as a set of operands (value repository) and a set of operators (operations representation) on these values is especially useful in the case of defining your custom types.

## 1.1.14. Summary

It is time to conclude and actually repeat. Simplifying, first, we can say that the type determines a set of values. The set of values that a variable can take. Second, the type specifies also the set of operations that are applicable to these values. Each type has its own set of operations and these operations - even if have the same names in different types - are performed differently. For existing well-known types some details of this definition could be replaced by other rules or even neglected. Next, we will investigate how to define custom types where all these details must be kept in mind without exception. Thank you for now and you are welcome to check out the next lesson..