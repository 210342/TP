# 1. Anonymous Types

## 1.1. Introduction

Again, let me stress that the CSharp language is strongly typed like many other programming languages. This means that it encourages and even forces designers to use of types for internal program consistency checking. The rules for checking the compatibility of types, apart from the rules for checking the syntax correctness, are one of the basic mechanisms for checking the correctness of the program content at design time. On the screen, we can see an example of such a type compatibility error. This example has been already discussed, so let me skip diving into the details now. The only feature worth stressing is that the compatibility of types supports using semantic rules to assign meaning to the text of the program and as a result to validate the program consistency. The role of type compatibility checking is similar to that of grammar checking in natural language text. In both cases, applying the rules does not guarantee that the spelling is correct. However, with their use, you can increase the probability that this statement makes sense.

As I said, this approach increases the correctness of the program probability in the context of internal data processing. If we want to pull or push data from/to external resources not directly manged by the selected language runtime environment we must answer the question of what type they are. How to correlate these external types with the types defined in the program. There are two good answers to this question. We can apply type conversion or data harmonization.

The purpose of this lesson is to learn about data harmonization. So let's talk about how the concept of anonymous type can help with this. The conversion will be the subject of independent episodes embedded in separate courses.

## 1.2. What is the problem?

A type name is often used to informally define semantic rules for that type, thus determining the meaning of each value belonging to the type. For example, CoordinatesClass tells us that we represent coordinates using reference data. Note that the word `Class` in the identifier `CoordinatesClass` duplicates the keyword used to define the type. Since it is redundant in this identifier, we can safely omit it in the production version of the program and reduce the identifier to `Coordinates`. Let us emphasize once again that types as a linguistic structure have the right to exist only within the content of the program at the design time and are applicable within the process that is a container executing the program at the run-time. So what concept we should apply to the external data managed outside of the selected programming language realm? And here we have to come back to the concept of the coding system referred to at the very beginning.

## 1.3. Coding system versus type concept

When defining coding systems, we very often use common names to identify them. For example, two's complement, natural binary, natural decimal, floating-point, and so on. Here, however, it should be emphasized that the rules for selected codes, for example, two's complement, natural binary, and natural decimal, are de facto standards. Others like the floating-point are international standards. Very often the codes have no name at all. Usually, they are defined indirectly. It means that they don't have a direct definition. As we recall our knowledge of the coding system concept, we know that each code consists of three parts. This is an alphabet which is a set of characters. The syntax is a set of rules describing how to concatenate characters into valid strings. And semantics, which determines the relationship between the correct strings of characters and their meaning, namely information. For numeric codes, there are also known operations on their words implementing algorithms applicable to the information they represent, for example, addition, subtraction, multiplication, and many others.

On the other hand, a type in the program body is represented by a unique identifier that indicates the type definition. The relationship between a type definition and its identifier is specified in the type declaration. Let me repeat that the definition of a type defines a set of values, and implicitly a set of information that is represented by a type and a set of operations that can be applied to the values belonging to that type.

But as a rule, it can also be assumed that we define codes using natural language, so this is an informal description. There are no validity rules defined for it. In this description, we often use terms and symbols used in mathematics, such as set designations, notation of functions, and similar. On the other hand, the type is defined as the text that is part of a program, so it must have a formal definition that is subject to validation in the context of the syntax and semantics of the selected programming language. Contrary to this, external data resides outside the program, precisely speaking it is managed outside the process hosting the program, namely archived, transmitted, and visualized with the use of various resources, such as file systems, database systems, computer networks, displays controlled by computers, and other devices. Usually, the prevailing requirement for external data is portability. Portability is the ability to use the same data by programs created in different programming languages. In this case, we must take into account the inability to directly use linguistic constructs of type definitions. You can only use universal standards, such as XML, JSON, or database schemas. If the type has an external definition, such as an XML schema, then we can convert that type and generate the equivalent type in the selected programming language. These issues are beyond the scope of this course and are of concern to us during the course on external data processing, but the relevant translations are already in the TP repository used in this course.

Concluding, supposing that the coding system and type play a similar role,  always we must deal with a type even if the data in concern resides in an external realm. If there exists a formal data type definition we could convert the definition to obtain a definition expressed using a selected programming language. If this scenario is not applicable we must apply types harmonization. In this process, the name of the external type doesn't exist at all. Hence, there is an idea to harmonize the external realm of data with the program employing types that has no name and no dedicated behavioral part, i.e. there are no specialized operations defined. Of course, each type must have some operations, unlike a coding system. In this case, we can consider also types that represent a typical data structure. For example, one that takes the form of a stream of key-value pairs. This lesson is about these types. It should be emphasized here that anonymous types are also useful in other scenarios, i.e. not only to facilitate interaction with the program's environment. Let's get started and move on to examples that illustrate the syntax and semantic rules of the language regarding anonymous types.

## 1.4. Lesson Scope and Goal

First, In this lesson, I will try to explain the difference between the meaning and scope of use of the `object` type and the `dynamic` and `var` keywords. The keyword `var` is specific to anonymous types. Secondly, I will move on to anonymous types and analyze the examples so that you can learn the syntax and semantic rules for anonymous types. In particular, I will pay special attention to how these types are defined. As planned, however, let's start by discussing the meaning and scope of the keywords `dynamic` and `var`.

## 1.5. Strict Versus Dynamic Typing

### 1.5.1. Strict Typing

Type Embedded Operations: In AntonymousTypesUnitTest.VARTest test method, we will start by revisiting an example we know from one of the previous lessons. In this example, we are dividing the integer five by the integer two and the result is the integer two. Next, we assign the constant five to the variable of type double. This causes the expression on the right assigned to the second double is using the division operation provided for the floating-point representations, I mean defined by the type double. Therefore, here the result of this action is already as expected, that is, we get the value of two and a half. If we changed the type of the first variable to `int`, in this case, the program is still correct, but the assertion is not fulfilled at this point, i.e. the error will appear while testing the program. I will run this test again. The reason for this is that both the variable and the constant are of the `int` 'type and the division operation follows the definition of that type. And here we see that we get the number two as a result of this division, and we expect the number two and a half. So let's go back to the previous type double, where the result of this test will be correct. We can run this test again. So much for a reminder on the definition of types, but let's go further.

Object type: We will try to do the same with a variable of type `object`. Recall that `object` is the type from which all other types inherit. The type `object` is the base type for all types, and for this variable, it is possible to assign a value that is of any type, since they are all derived. In this case, the value is of type `int`. Since this is an `int`, let's try the add operation. As we can see, the compiler signals us that this operation is impossible, because the addition operation has not been defined for the `object` type. The apparent paradox is that the value of this variable is still of type `int`, as we can see in the next line. It is only apparently inconsistent because the correctness of the code does not depend on the type of value assigned to the variable, but is evaluated based only on the variable type itself. At design time we don't have values. This is an important observation because the type-based consistency assessment can be used at the design time, while the value-based consistency assessment can only be used at run time. One can imagine a scenario where many years will pass between the program being created and its execution. Let me quote the old saying of programmers, once the author and God did know how this program works, today only God knows.

var keyword: To evaluate the meaning and scope of the var keyword, let's go back to the code we know from the previous lesson, in which we have an int variable. In this case, it is the `Int32` represented by the identifier `int`. The identifier `int` is an alias for the name of the type Int32. And we will continue to perform the division operation. But the interesting thing about language is that we can use the `var` keyword instead of a type identifier. The question is what is the difference between both cases, namely using the explicit identifier of a selected type, and alternatively replacing this identifier with the `var` keyword. In this case, the `var` keyword causes the variable prefixed with `var` can be assigned any value just like in the case of the `object` type and `dynamic` keyword. However, unlike in the mentioned cases, we cannot change the variable type anymore. The variable type is inferred from the value type and will be unchangeable after this first assignment. Attempting to assign a string to a variable of type `int` results in a compiler error saying that the types are not compatible. So the type of this variable is `int`.

Anyway, this program still behaves similarly to the previous one, i.e. dividing the value five by two for integers returns two. What does it mean? This means that the type of the variable has not changed. It's still `int`, so the word `var` actually replaced the keyword int for compilation purposes only.

### 1.5.2. Dynamic Typing

Sometimes, especially when we have to deal with the external data, type definition at design time is impractical or even impossible. In this scenario, we must postpone any consideration regarding type design up to the run time. This case is the subject of an examination in the next line of code when we use the dynamic keyword instead of the type identifier.

What does dynamic mean? First, using the dynamic keyword means that we are recommending the compiler to stop compliance type-checking at the design time. Compliance of the type is conducted when the program is being executed and also under certain assumptions. The runtime can vary, so its response to these situations is not always the same. But as a rule of thumb, we can assume that the environment behavior is smart enough so as not to cause execution errors, if possible.

W kolejnej linijce zamiast identyfikatora typu używamy słowa kluczowego dynamic. Co to znaczy dynamic? Dynamic w tym przypadku znaczy to, że upraszczając, mówimy kompilatorowi, aby przestał sprawdzać zgodność typów na etapie tworzenia programu. Zgodność typ lub raczej brak możliwości jego wykonania jest sprawdzana dopiero w momencie kiedy program jest realizowany i to też przy pewnych założeniach. Środowisko wykonawcze może się różnić, więc jego reakcja na takie sytuacje nie zawsze jest taka sama. Ale jako regułę możemy przyjąć, żę środowiska jest tak skonstruowane, aby nie powodować będów wykonania, o ile to jest możliwe.

An example is here. Here we can see that we have assigned the value of type `int` to the variable `dynamic`, that is, the number 0. In this line, the invariant indicates that the result is always 1, so the preceding addition is successfully performed. But in the next line of code, we can see that the type of this variable can change, because we have assigned a value of the string type to it. We can see that the value of this variable is equal to "String", so the type of the variable now should be considered the string. Here we try to add but generally for a string and a numerical value such an operation does not make sense. But what does the compiler do? The compiler converts a double value to a string value and performs plus operations for the string type, which in this case is defined and means concatenation, joining two texts together. Here we have the result. An interesting fact is that as a result, we can have a comma instead of a period. This is because the double value conversion is implemented, using the local language system settings used for communication with used by the operating system.

## 1.6. Anonymous Type

The use of the var keyword is often overused. By design, it should only be used when it actually needs to be used, i.e. with anonymous types. As the name says for anonymous types the name is not explicitly provided in the type definition, therefore, to keep the syntax intact the type identifier has to be replaced by the var keyword.

Now let's move on to discussing this kind of type.

### 1.6.1. AnonymousTypesUnitTest.AnonymousType test method

In this line of the code, we use the anonymous type to define the set of allowed values ​​for the variable `_anonymousVariable`. The most important feature of this approach is that the entire set is defined based on one selected value. This type is actually defined by a constant which is to the right of the assigning sign. The notation of this constant has a strictly defined syntax. The word `var` must be used instead of a type name because a type defined in this way cannot have a name - hence we call it anonymous type. Based on this syntax we can conclude that the values ​​belonging to this set - to the defined this way type - are complex because they have component values. In our example, it is a number and a string. Identifiers are recognized as the read-only variables. Therefore, we can simply state that in this statement a complex constant is assigned to the variable `_anonymousVariable`. Such an indirect way of defining a type also makes it impossible to define a set of own, dedicated operations that can be applied to process values belonging to this type. For anonymous types defined this way, several standard operations have been defined. Standard operations are those whose behavior is determined by the programming language, not the software developer. They include the selector operation, which allows to access the selected component value in the complex value defined this way. Examples of this operation can be found in the next two lines of the analyzed example, where the values of embedded components are checked.

Here, it is worth asking if anonymous types are still protected by the type compatibility validation mechanism. Because the type is anonymous, it only means that its name is hidden for the developers of the program. Contrary, the compiler can create such a name for its own purposes. To enable type compatibility checking, we need to know what values ​​belong to the type. In the following lines of the example, we can see that trying to assign a new value to the `Amount` field is rejected (in this case "double ") with the one we previously used, when we declared the variable for the first time, and then it was "int", this causes the type compatibility error. Apparently, it is in the next line, when we change the order of the fields. Also, in this case, an error is signaled and this constant will not be treated as a value of a compatible type that was created when this variable is declared. The next two lines show that we cannot change the values ​​of the components.

Additionally, this line proves that it is a reference type because you can substitute null as a value for variables of this type, meaning that there is really no value. But trying to substitute null for a new variable prefixed with the keyword `var`, in this case, _newAnonymousVariable fails because the compiler does not have enough information to define the new type. In other words, we can say that the value to be assigned to an anonymous variable must have the appropriate syntax, where the keyword `new` must appear, and between the curly brackets a string of identifiers, equal signs, and expressions that determine the values substituted for each member.

### 1.6.2. AnonymousTypesCompatibilityTest method

The next test method shows that we can define the same anonymous types even though the anonymous types do not have a name. In fact, the compiler for each anonymous type creates its own identifier, which is not available to us but is available to the compiler. Here we have two variables that are defined very similarly, that is, they have the same components and we substitute some values for them. The result type of value is determined by the types of member values, identifiers of the members, and their order. And then we can check that indeed these two variables are of the same type and we can, for example, assigned one to the other ones.

## 1.7. Conclusion

Anonymous types are characterized by the fact that when defining a new anonymous type, we cannot define specialized operations for it that can be applied to process values of this type. Another feature of this kind of type is that it defines a sequence of key-value pairs. These two characteristics indicate that this type is particularly well suited to represent external data. In other words, external data has no type in the sense we use in the programming language. As a rule of thumb, for external data, operations are performed outside of the process hosting the programming realm, so they cannot be used locally. If this approach is not sufficient and dedicated operations are needed, then instead of data harmonization, we should use type conversions, but this is an independent story.

## 1.8. Homework

We are approaching the end of the lesson, and traditionally it is a good time to define your homework. I have the following questions to start with.

1. Why does the variable prefixed by the dynamic keyword has the value of one point five. My concern is about the comma instead of dot character in the indicated place in the program?
2. Why there is an exception in this line of the code, where does it come from, and what is the justification that this exception occurs there.
3. In the indicated test, please add invariants (assertions) that check the current type of the dynamic variable. As we said, this variable changes type during program execution.

## 1.9. That's all for now

That's all about anonymous types. Again, let me stress this concept is especially useful when talking about external data where the type concept is applicable only indirectly, and where the types don't have names. Thank you for your time.
